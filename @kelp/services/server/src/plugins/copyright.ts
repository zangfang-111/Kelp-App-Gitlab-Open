import { gql, makeExtendSchemaPlugin } from 'graphile-utils'
import { QueryConfig } from 'pg'
import { OurGraphQLContext } from '../middleware/installPostGraphile'
import { generateSQLPrepareValuesForBulk } from '../utils/dbHelpers'
import { CurrentUserIdFunction } from './user'
interface MediaCopyright {
  signer: string
  statementId: string
  poeId: string
}

/**
 * Maps `{poeId:mediaId}`
 */
interface PoeIdMediaIdSQLResult {
  id: number
  poe_id: string
}

interface CopyrightTable {
  user_id: number
  media_id: number
  statement_id: string
  signer: string
}

/**
 * Transform the SQL result to cached list so we can easily get the media ID in one go
 * @param params
 */
function makePoeMediaObjectMap(
  params: PoeIdMediaIdSQLResult[],
): {
  [k: string]: number
} {
  const ret: {
    [k: string]: number
  } = {}
  params.forEach((m) => {
    const { poe_id, id } = m
    if (poe_id in ret) {
      throw new Error('Existing PoE already found in the list. Check the Input for the mutation.')
    }

    ret[poe_id] = id
  })

  return ret
}

export const UserPlugin = makeExtendSchemaPlugin(() => {
  return {
    typeDefs: gql`
      """
      Information needed to store the copyright for a given media via its Proof-of-Existence
      """
      input MediaCopyright {
        """
        URN based signer address urn:pgp:key-fingerprint
        """
        signer: String!
        """
        IPTC entity for the copyright. check the type or go [here](https://iptc.org/std/photometadata/specification/IPTC-PhotoMetadata#entity-or-concept-structure) for the declaration
        Identifier is a StatementID decoded from the chain. It's a [CID](https://sensio.dev/
        Name for this statement, this is autogenerated field and it can be anythingglossary.html#cid)
        """
        statementId: String!
        """
        Proof of existence as specified [HERE](https://sensio.dev/network/protocol/proof.html)
        """
        poeId: String!
      }

      """
      If this is true then all updates are done and saved. Listen for errors in case of the failures.
      """
      type MediaPayload {
        """
        Did we succeed with mutation. Pretty much everything will succeed unless there are DB errors. It will succeed even if there are multiple values already stored. In that case check next return param
        """
        success: Boolean!
        """
        How many records we inserted. This will be a nubmer === inserted.length or 0 of there are no inserted records. In that case it means we already have them in the DB
        """
        inserted: Int!

        """
        How many records we passed in.
        """
        passed: Int!
      }
      extend type Mutation {
        """
        Update the media with the created copyright statements
        """
        updateMediaCopyright(input: [MediaCopyright!]!): MediaPayload
      }
    `,
    resolvers: {
      Mutation: {
        async updateMediaCopyright(
          _mutation,
          args: { input: MediaCopyright[] },
          { pgClient }: OurGraphQLContext,
        ) {
          const { input } = args
          await pgClient.query('SAVEPOINT update_media_copyright')
          try {
            // 1. get all the media IDs for every PoE
            const poeIdsPlaceholderValues = input.map((m) => `${m.poeId}`)
            const poeIdsPlaceholderPrepValues = input.map((m, i) => `$${i + 1}`)

            const getMediaIdsQuery: QueryConfig = {
              text: `select m.id, m.poe_id from app_public.media m
            where m.poe_id in (${poeIdsPlaceholderPrepValues});`,
              values: poeIdsPlaceholderValues,
            }
            // get the media with the poeId for future mapping
            const { rows } = await pgClient.query<PoeIdMediaIdSQLResult>(getMediaIdsQuery)

            // format the rows to be in the format [{poeId:mediaId}, ...]
            const poeMediaObject = makePoeMediaObjectMap(rows)

            const {
              rows: [user],
            } = await pgClient.query<CurrentUserIdFunction>(`select app_public.current_user_id();`)

            // 2. create the input and get the data

            const dataPayload: CopyrightTable[] = input.map((i) => {
              return {
                media_id: poeMediaObject[i.poeId],
                statement_id: i.statementId,
                user_id: user.current_user_id,
                signer: i.signer,
              }
            })

            // 3. build the insert vars
            const {
              columns,
              preparedValues,
              values,
            } = generateSQLPrepareValuesForBulk<CopyrightTable>(dataPayload)

            const insertQuery: QueryConfig = {
              text: `INSERT INTO network.copyright (${columns}) VALUES ${preparedValues} ON CONFLICT DO NOTHING RETURNING *;`,
              values,
            }

            const { rows: insertedRows } = await pgClient.query(insertQuery)

            return { success: true, inserted: insertedRows.length, passed: input.length }
          } catch (error) {
            await pgClient.query('ROLLBACK TO SAVEPOINT update_media_copyright')
            throw error
          } finally {
            // Release our savepoint so it doesn't conflict with other mutations
            await pgClient.query('RELEASE SAVEPOINT update_media_copyright')
          }
        },
      },
    },
  }
})

export default UserPlugin
